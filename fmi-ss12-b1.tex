\documentclass [11pt]{article}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{epsfig} 
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{algorithm}
%\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{listings}


   \textwidth      15cm
   \textheight     23cm
   \oddsidemargin 0.5cm
   \topmargin    -0.5cm
   \evensidemargin\oddsidemargin

 \newcommand{\nop}[1]{}


   \pagestyle{plain}
   \bibliographystyle{plain}


\newenvironment{mylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\scriptsize\bfseries}
{\end{list}}

\newenvironment{mytinylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\tiny\bfseries}
{\end{list}}



\title{Formale Methoden der Informatik \\
Block 1: Computability and Complexity }
\author{Exercises 1-10}
\date{SS 2012}


  \newtheorem{theorem}{Theorem}
  \newtheorem{lemma}[theorem]{Lemma}
  \newtheorem{corollary}[theorem]{Corollary}
  \newtheorem{proposition}[theorem]{Proposition}
  \newtheorem{conjecture}[theorem]{Conjecture}
  \newtheorem{definition}[theorem]{Definition}
  \newtheorem{example}[theorem]{Example}
  \newtheorem{remark}[theorem]{Remark}
  \newtheorem{exercise}[theorem]{Exercise}

  \newcommand{\ra}{\rightarrow}
  \newcommand{\Ra}{\Rightarrow}
  \newcommand{\La}{\Leftarrow}
  \newcommand{\la}{\leftarrow}
  \newcommand{\LR}{\Leftrightarrow}

  \renewcommand{\phi}{\varphi}
  \renewcommand{\theta}{\vartheta}


\newcommand{\ccfont}[1]{\protect\mathsf{#1}}
\newcommand{\NP}{\ccfont{NP}}

\newcommand{\NN}{\textbf{N}}
\newcommand{\IN}{\textbf{Z}}
\newcommand{\bigO}{\mathrm{O}}
\newcommand{\bigOmega}{\Omega}
\newcommand{\bigTheta}{\Theta}
\newcommand{\REACHABILITY}{\mbox{\bf REACHABILITY}}
\newcommand{\MAXFLOW}{\mbox{\bf MAX FLOW}}
\newcommand{\MAXFLOWD}{\mbox{\bf MAX FLOW(D)}}
\newcommand{\MAXFLOWSUB}{\mbox{\bf MAX FLOW SUBOPTIMAL}}
\newcommand{\MATCHING}{\mbox{\bf BIPARTITE MATCHING}}
\newcommand{\TSP}{\mbox{\bf TSP}}
\newcommand{\TSPD}{\mbox{\bf TSP(D)}}

\newcommand{\ThreeCol}{\mbox{\bf 3-COLORABILITY}}
\newcommand{\TwoCol}{\mbox{\bf 2-COLORABILITY}}
\newcommand{\kCol}{\mbox{\bf k-COLORABILITY}}
\newcommand{\HamPath}{\mbox{\bf HAMILTON-PATH}}
\newcommand{\HamCycle}{\mbox{\bf HAMILTON-CYCLE}}

\newcommand{\ONESAT}{\mbox{\bf 1-IN-3-SAT}}
\newcommand{\MONONESAT}{\mbox{\bf MONOTONE 1-IN-3-SAT}}
\newcommand{\kSAT}{\mbox{\bf k-SAT}}
\newcommand{\NAESAT}{\mbox{\bf NAESAT}}
\newcommand{\CLIQUE}{\textbf{CLIQUE}\xspace} 
\newcommand{\VC}{\textbf{VERTEX COVER}\xspace}



\renewcommand{\labelenumi}{(\alph{enumi})}

%%% useful macros for Turing machines:
\newcommand{\blank}{\sqcup}
\newcommand{\ssym}{\triangleright}
\newcommand{\esym}{\triangleleft}
\newcommand{\halt}{\mbox{h}}
\newcommand{\yess}{\mbox{``yes''}}
\newcommand{\nos}{\mbox{``no''}}
\newcommand{\lmove}{\leftarrow}
\newcommand{\rmove}{\rightarrow}
\newcommand{\stay}{-}
\newcommand{\diverge}{\nearrow}
\newcommand{\yields}[1]{\stackrel{#1}{\rightarrow}}

\newcommand{\HALTING}{\mbox{\bf HALTING}}

\newcommand{\true}{{\it true}}
\newcommand{\false}{{\it false}}
%\newcommand{\samplesolution}[1]{\noindent {\bf Sample solution.}  #1}
\newcommand{\solution}[1]{\noindent {\bf Solution.}  #1}

\floatname{algorithm}{Procedure}
%\renewcommand{\algorithmicrequire}{\textbf{Input:}}
%\renewcommand{\algorithmicensure}{\textbf{Output:}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\maketitle


\begin{exercise}
  Consider the problem \textbf{PROCEDURE NEG-ASSIGNMENT}, which is defined
  as follows:

  \begin{center}
    \fbox{
      \begin{minipage}[c]{.9\linewidth}
        \textbf{PROCEDURE NEG-ASSIGNMENT}

        \medskip INSTANCE: A triple $(\Pi,I, k)$, where (i) $\Pi$ is a
        program that takes one string as input and outputs true or false, (ii) $I$ is a
        string, and (iii) $k$ is an integer variable used in program $\Pi$.     \\
        QUESTION: Does variable $k$ ever get assigned a negative value when the program $\Pi$ is executed with input $I$?

        
      \end{minipage}
    }
  \end{center}
  Prove that \textbf{NEG-ASSIGNMENT} is undecidable. Prove the undecidability
  by providing a reduction from the \textbf{HALTING} problem to
  \textbf{NEG-ASSIGNMENT}, and arguing that your reduction is correct.
\end{exercise}


\solution

To prove the reduction, we have to show that 

\bigskip

$\Pi'$ halts on I $<==>(\Pi, I, k)$ is a positive instance of NEG-ASSIGNMENT.

\bigskip

Let $(\Pi', I') $ be an arbitrary instance of HALTING.  Set $I = I' = S $, let be k an arbitrary integer occuring in $\Pi$ and  construct $(\Pi, I, k) $ in the following way: 

\smallskip


\begin{algorithm}
\caption{NEG-ASSIGNMENT Procedure}
\label{<your label for references later in your document>}
\begin{algorithmic}

\Function{$\Pi$}{String $S$}
 \State int $k = 0$
 %\State I' = I;
 \State call $\Pi^\prime(S)$
 \State k = -1;
 \State return TRUE;
\EndFunction

\end{algorithmic}
\end{algorithm}

\bigskip


$"=>"$

\bigskip

Assume that ($\Pi', I'$ ) is a positive instance of halting, so $\Pi'$ halts on $I$ because we set $I = I'$. Directly after the termination of $\Pi'$, we set $k=-1$, so $(\Pi, I, k)$ is a positive instance of NEG-ASSIGNMENT. 

\bigskip

$"<="$

\bigskip

Assume that $(\Pi, I, k)$ is a positive instance of NEG-ASSIGNMENT, so it returns TRUE which means that k gets negative and the program terminates. But the only time when k gets set to a negative value is directly after the call of $(\Pi', I')$, where $I=I'$, so $\Pi$ halts on $I$, so $(\Pi', I')$ is a positive instance of HALTING. 

\bigskip

\begin{exercise}
  Prove that the problem \textbf{NEG-ASSIGNMENT} from Exercise 1 is semi-decidable. 
To this end, provide a semi-decision procedure and justify your solution. Additionally,  show that the co-problem of \textbf{NEG-ASSIGNMENT} is not semi-decidable.
\end{exercise}

\solution i)

Consider the following interpreter for NEG-ASSIGNMENT. For semi-decidability, the program must return TRUE for all positive instances $(\Pi, I, k)$. The behaviour for negative instances $(\Pi, I, k)$ is such that $\Pi$ return FALSE or loops forever.
So we have to distinguish the following cases:

\begin{itemize}
\item POSITIVE INSTANCE $(\Pi', I')$
\begin{itemize}
\item When $(\Pi', I')$ halts on input $I$, $(\Pi', I')$ is a POSITIVE instance for our halting program, so the variable k gets assigned a negative value and therefore $(\Pi, I, k)$ is a positive assignment of NEG-ASSIGNMENT and returns TRUE
\end{itemize}
\item NEGATIVE INSTANCE $(\Pi', I')$
\begin{itemize}
\item  When $(\Pi', I')$ is a  NEGATIVE instance for our halting program and halts, the variable is NOT touched by our interpreter and remains positive, so $(\Pi, I, k)$ is a NEGATIVE instance on $I$ and returns FALSE
\item When $(\Pi', I')$ is a  NEGATIVE instance for our halting program but does not halt, the variable k cannot be NOT touched by our interpreter and remains positive, so $(\Pi, I, k)$ is a NEGATIVE instance on $I$ and loops forever, which is OK for a semi-decision procedure.
\end{itemize}
\end{itemize}


\begin{algorithm}
\caption{Interpreter for NEG-ASSIGNMENT }
\label{intNEG}
\begin{algorithmic}

\Function{$\Pi$}{String $S$}
 \State int $k = 0$
 \State rc = call $\Pi^\prime(S)$
 \If{$rc = TRUE$}
 \State k = -1;
  \State return TRUE;
 \Else
 \State return FALSE;
 \EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}

\solution ii)

Since we showed that NEG-ASSIGNMENT is undecidable and semi decidable the CO-NEG-ASSIGNMENT is not semi decidable. If the CO-NEG-ASSIGNMENT would be semi- decidable we could build a procedure that the NEG-ASSIGNMENT is decidable. This would be a contradiction.

\begin{exercise}
  Give a formal proof that \textbf{SUBSET SUM} is in $\NP$, i.e.\, define a
  certificate relation and discuss that it is polynomially balanced and
  polynomial-time decidable.
  
   \smallskip
    
  \noindent In the \textbf{SUBSET SUM} problem we are given a finite set of integer numbers $S=\{a_1, a_2, \ldots, a_n\}$ and an integer number $t$. We ask whether there is a subset $S'\subseteq S$ whose elements sum is equal to $t$?
  
\end{exercise}


\solution{ 3}
   \smallskip
First we have to define a certificate relation with an arbitrary t:

\bigskip

$R = \{ [(S,t),S']|  S' \subseteq S $ with $ \sum(S') = t \} $ 

\bigskip
We argue that R is a certificate relation for SUBSET-SUM. $(S,t)$ is a positive instance of SUBSET-SUM $ \Leftrightarrow $ there exist a $S'$ which sum is equal to $t$.   

\bigskip

R is polynomially balanced because any subset of $S$ can be represented in space that is linear in the size in $S$.

\bigskip

Finally R is decidable in polynomial time because, for a given subset of $S$ we can easily check that a the sum is equal to $t$. This needs at most n computational steps. So it can be done in polynomial time.


\begin{exercise}
  \label{ex:partition}
  Formally prove that \textbf{PARTITION} is $\NP$-complete. For this you may use
  the fact that \textbf{SUBSET SUM} is $\NP$-complete.   
  
  \smallskip
  \noindent In the \textbf{PARTITION} problem we are given a finite set of integers $S=\{a_1, a_2, \ldots, a_n\}$. We ask whether the set $S$ can be partitioned into two sets $S_1, S_2$ such that the sum of the numbers in $S1$ equals the sum of the numbers in $S_2$? 
  

\end{exercise}


\solution




\begin{exercise}
  \label{ex:frequency}
  Formally prove that \textbf{FREQUENCY ASSIGNMENT} is $\NP$-complete. For this you may use
  the fact that a similar problem used in lectures is $\NP$-complete.
      
    \smallskip
        
  \noindent In the \textbf{FREQUENCY ASSIGNMENT} problem we are given a set of transmitters $T=\{t_1, t_2, \ldots, t_n\}$,  $k$ frequencies, and the list of pairs of transmitters that interfer and therefore cannot use the same frequency. We ask whether there is an assignment of each transmitter to one of $k$ frequencies such that there is no interference between the transmitters. 
            
\end{exercise}

\solution{ 5}

The FREQUENCY ASSIGNMENT problem can be mapped to the K-COLORABILITY GRAPH problem in the following way: every edge of the graph G(V, E) corresponds to a sending terminal, where each of this terminals can use one of the k frequencies that are available. The edges of G(V, E) show what terminals would interfere with each other(are in transmission range) - so 2 transmitters which are connected by  an edge MUST NOT use the same frequency, in other words MUST NOT have the same color on the 2 vertices, connected by the edge.

First, we have to show that FREQ-ASSIGNMENT is in NP. Therefore, we guess a frequency assignment and check whether two adjacent vertices have the same color. This can be done in polynomial time by looping through all transmitting stations and comparing its color with the color of all neighbour-stations.

\medskip

 $G(V, E)$ is a positive instance of k-Colorability $\Leftrightarrow$ positive instance of FREQ-ASSIGNMENT

$ "\Rightarrow" $

Suppose G(V, E) is a positive instance of k-colorability, then the color of the edge, name it $i$, is mapped to the frequency $i$. Finally, we get a correct frequency assignment because we started with a correct k-coloring.

\medskip

$ "\Leftarrow" $

In the other direction it is possible to argue in the same way: the FREQ-ASSIGNMENT for the k transmitter-frequencies {1,...,k} is mapped to the k-coloring by using color $i$ for the corresponding edge.

\begin{exercise}
  \label{ex:CO-NP}
  Fomally prove that logical entailment is $co-\NP$-complete. The formal definition of entailment ( $\models$) is this: $\alpha \models \beta$ if and only if, in every truth assignment in which $\alpha$ is true, $\beta$ is also true.  
\end{exercise}


%\solution{ Your solution here.}



\begin{exercise}
  \label{ex:Colors}
  It is well known that the \textbf{k-COLORABILITY} problem is $\NP$-complete for every $k \geq 3$. Recall that the instance of \textbf{k-COLORABILITY} is an undirected graph $G = (V, E)$. Suppose that we restrict this instance of \textbf{k-COLORABILITY} to trees. Can the restricted problem be solved with an algorithm that runs in polynomial time? If yes, provide such an algorithm. 
\end{exercise}


\solution

By definition, a tree MUST NOT contain any cycles. By modifying DEPTH or BREADTH FIRST SEARCH, we get an algorithm for k-colorability that works in polynominally time. Consider a tree with n - nodes, where every parent-node has x child nodes. One extreme example would be a tree where every node has exactly 1 child. The other extreme would be a tree with 1 parentnode and n-1 childnodes, directly attached to the parent.

Our algorithm has to process every level of the tree, starting at the root-node, coloring the node with one out of k colors. Afterwards, the next level has to be processed. If we take again the extreme with only 2 levels(1 parent, n-1 childs), we have to color (n-1) nodes and the program has finished. Otherwise, if every node has one child, only 1 node has to be colored with another color. This step then must be repeated n times.

Normaly, an average tree will be a mixture of the 2 extremes. This means that we have at most $n$ levels, with $(n-1)$ nodes at each level, which means that the algorithm is $O(n^2)$.  

\begin{mylisting}
\begin{verbatim}

for( every level of the tree )
{
   for( every node in this level )
   {
      color(node, color);
   }
   increment color(color);
}

\end{verbatim}
\end{mylisting}

\begin{algorithmic}
\Function{DFS}{$a$}
\For {each vertex $u \in V[G]$}
% \If {$i\geq maxval$}
    \State $i\gets 0$
% \Else
    color[u] $\gets$ k
    \If {$i+k\leq maxval$}
        \State $i\gets i+k$
    \EndIf
\EndFor
\EndFunction
\end{algorithmic}


\begin{exercise}
  \label{ex:Nqueens}
  Provide a reduction of \textbf{N-Queens} problem to \textbf{SAT}. Give a proof sketch of the correctness of your reduction. Does this implies that the \textbf{N-Queens} is an $\NP$-complete problem? Argue your answer.  
  
  \smallskip 
  
\noindent In the \textbf{N-Queens} problem we are given $n$ queens and an $n \times n$ chessboard. We ask whether we can place these $n$ queens on the  chessboard such that no two queens attack each other. Two queens attack each other if they are placed in the same row, or in the same column, or in the same diagonal.    
       
   
\end{exercise}


\solution{ 8}
For the  N-queens problem we consider  a generalized chess board, which squares divided into $n x n$  squares. The problem is to place N-queens on it in such way that o queen attacks any other (for further information use google).  To reduce the N-queen problem to a SAT instance we have to construct a clause for each rule of the n-queens problem. Then the formula $ \phi$ is defined as follows:

 \begin{center}
 \begin{itemize}
\item $ \alpha_1 = \bigwedge _{i=1} ^{n}   \bigwedge _{j=1} ^{n}   \bigwedge _{k=j+1} ^{n} (\neg s_{ij} \vee \neg s_{ik} ) $
\item $ \alpha_2 = \bigwedge _{i=1} ^{n}   \bigwedge _{j=1} ^{n}   \bigwedge _{k=j+1} ^{n} (\neg s_{ji} \vee \neg s_{ki} ) $
\item $ \alpha_3 = \bigwedge _{d=0} ^{n-2}   \bigwedge _{j=1} ^{n-d}   \bigwedge _{k=j+1} ^{n-} (\neg s_{((d+j),j)} \vee \neg s_{((d+k),k} )) $
\item $ \alpha_4 = \bigwedge _{d=-(n-2)} ^{-1}   \bigwedge _{j=1} ^{n+d}   \bigwedge _{k=j+1} ^{n+d} (\neg s_{(j,(j-d))} \vee \neg s_{(k,(k-d)} )) $
\item $ \alpha_5 = \bigwedge _{d=3} ^{n+1}   \bigwedge _{j=1} ^{d-1}   \bigwedge _{k=j+1} ^{d-1} (\neg s_{(j,(d-j))} \vee \neg s_{(k,(k-d)} )) $
\item $ \alpha_6 = \bigwedge _{d=n+2} ^{2n-1}   \bigwedge _{j=d-n} ^{n}   \bigwedge _{k=j+1} ^{d-1} (\neg s_{(j,(d-j))} \vee \neg s_{(k,(k-d)} )) $
\item $ \alpha_7 = \bigwedge _{i=1} ^{n}   \bigvee _{j=1} ^{n} (s_{ij}) $

  \bigskip
\item $\phi =  \alpha_1 \vee \alpha_2 \vee \alpha_3 \vee \alpha_4 \vee \alpha_5 \vee \alpha_6 \vee \alpha_7$ 

 \end{itemize}
\end{center}

The formula $\phi$ ensures that all restrictions from the N-Queens Problem are fulfilled. In detail:
 \begin{itemize}
\item  $ \alpha_1 $ ensures that each column contains AT MOST one queen
\item  $ \alpha_2 $ ensures that each row contains AT MOST one queen
\item  $ \alpha_3 $ ensures that one queen must occur AT MOST for the postiv values of $d=i-J$ in the bottom left to upper right diagonal line. (We split the diagonals in to parts, bottom left to upper right and upper left to bottom right )
\item  $ \alpha_4 $ ensures that one queen must occur AT MOST for the negativ values of $d=i-J$ in the upper left to bottom right  diagonal line.

 \end{itemize}

\bigskip
Prove the proof both direction of the correctness of the reduction ,
i.e. prove the following statement: if $\phi$ is satisfiable, then the placement of the N-Queens is valid for the N-QUEENS problem. We only preform a proof sketch of the whole problem.

 \begin{itemize}
\item Direction "$\Leftarrow$" 
Suppose $\phi$ is satisfiable , i.e. there is a truth assignment T under
which all subformulae  $ \alpha_i, 1 \leq i \leq 7$ , evaluate to true. We have to show
that there exist a valid placement of the N-Queens . We let $C$ be the set of all squares. The variable $T_{i,j}$ is set to be TRUE if  the the row $i$ and the column $j$ contains a queen. We have to define a truth assignment such that each variable $v$  which is true in the formula of SAT there has to have a corresponding variable $w$ which will be set also to true in the N-QUEENS instance. If the formula is satisfiable in SAT then the formula is also satisfiable in N-Queens with the corresponding variables.

\item Direction "$\Rightarrow$" 
Suppose we have a valid instance of the N-Queens problem , i.e. there is a truth assignment T under
which all constrains of the problems are fulfilled ,and the problem instance evaluate to true. We have to show
that there exist a valid assignment of each Clause that the SAT instance is ture. We have to define a truth assignment such that each variable $w$  which contains a queen has to have a corresponding variable $v$ which will set the SAT clause to true. So if we have a valid instance of the N-Queens problem there must also be a valid formula $\phi$ with the corresponding variable.

 \end{itemize}



 
 
 \begin{exercise}
  Consider the following problem:
  \begin{center}
    \fbox{
      \begin{minipage}[c]{.95\linewidth}
        \textbf{N-SORTED-ELEMENTS}

        \medskip

        INSTANCE: A non-empty list $L=(e_1,\ldots,e_n)$ of non-negative integers. \\
        QUESTION: Does the list $L$ contain a sub-list of $k$ consecutive sorted numbers in ascending order (from left to right)?
      \end{minipage}
    }
  \end{center}

  \medskip Argue that \textbf{N-SORTED-ELEMENTS} can be solved using only logarithmic
  space.
\end{exercise}


\solution{ 9}
To show that problem is solvable in logarithmic space we have to take a look on the elements we need to solve the problem. We only need one pointer to an element in the list and a counter. Both require only logarithmic space. The pseudo algorithm  for
N-SORTED-ELEMENTS works as follows:

\begin{algorithm}
\caption{Boolean N-SORTED-ELEMENTS }
\label{Bsort}
\begin{algorithmic}

\Function{Boolean N-SORTED-ELEMENTS}{List $L$, Integer $k$}
 \State int $i$ ;
 \State int $counter = 0$;
  \For{ i from 2 to length $L$} 
  \If{$L[i] > L[(i-1)]$ then $counter = counter +1$}
   \If{ $ counter  \geq  k$}  return $TRUE$
   \EndIf
   \Else{ $counter = 0$;}
  \EndIf
 \EndFor
 \State return $FALSE$
\EndFunction
\end{algorithmic}
\end{algorithm}

\medskip
The procedure (see procedure 3) uses 2 variables i  and a  counter. For a list $ L = (e1; : : : ; en) $,
the variable i need log n bits to be represented. The
variable counter also only needs logarithmic space. Such a value max needs only
$ log 2^64 x n) = log 2^64 + log n = 64 + log n$ when we assume that the integers are 64-bit integer.
So we can see that the procedure needs only logarithmic space to be represented.



\begin{exercise}
  \label{ex:turing}

  Design a Turing machine that increments by one a value represented by a string of 0s and 1s.
  
\bigskip  
  
\solution{10}

Consider the turing machine M for adding a single $1$ to a string of $0$s and $1$s

\medskip

$M=(K, \sigma, \delta, s)$ with $K = \{START, RIGHT, LEFT, CARRY, OVERFLOW, ZERO, END\}$, $\sigma=\{0, 1, \sqcup, \triangleright\}$ and the transition function $\delta$

\bigskip
  
\begin{tabular}{|l|c||r|}
\hline p $\in $ K   & $\sigma \in \Sigma $  & $\delta(p, \sigma)$ \\ 
\hline
\hline  $START$  & $\triangleright$ & ($NO, \sqcup,\--$ ) \\ 
\hline  $START$ & $0$  & $(RIGHT, 0, \rightarrow)$\\ 
\hline  $START$ & $1$  & $(RIGHT, 1, \rightarrow)$ \\ 

\hline  $RIGHT$ & $0$  & $(RIGHT, 0, \rightarrow)$ \\ 
\hline  $RIGHT$ & $1$  & $(RIGHT, 1, \rightarrow)$ \\ 
\hline  $RIGHT$ & $\sqcup$  & $(LEFT, \sqcup, \leftarrow)$ \\ 

\hline  $LEFT$ & $0$  & $(YES, 1, \--)$ \\ 
\hline  $LEFT$ & $1$  & $(CARRY, 0, \leftarrow)$\\ 

\hline  $CARRY$ & $0$  &$(YES, 1, \--)$\\ 
\hline  $CARRY$ & $1$  & $(CARRY, 0, \leftarrow)$\\ 
\hline  $CARRY$  & $\triangleright$ & $(OVERFLOW, \triangleright, \rightarrow)$ \\ 

\hline  $OVERFLOW$ & $1$  & $(ZERO, 1, \rightarrow)$ \\ 

\hline  $ZERO$ & $1$  & $(ZERO, 0, \rightarrow)$ \\ 
\hline  $ZERO$ & $\sqcup$  & $(END, 0, \rightarrow)$ \\ 

\hline  $END$ & $\sqcup$  & $(YES, \sqcup, \--)$ \\ 

\hline 
\end{tabular} 
\end{exercise}


%\solution{ Your solution here.}



\end{document}


