\documentclass [11pt]{article}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{epsfig} 
\usepackage{enumerate}
\usepackage{xspace}
\usepackage{algorithm}
%\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{listings}


   \textwidth      15cm
   \textheight     23cm
   \oddsidemargin 0.5cm
   \topmargin    -0.5cm
   \evensidemargin\oddsidemargin

 \newcommand{\nop}[1]{}


   \pagestyle{plain}
   \bibliographystyle{plain}


\newenvironment{mylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\scriptsize\bfseries}
{\end{list}}

\newenvironment{mytinylisting}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\tiny\bfseries}
{\end{list}}



\title{Formale Methoden der Informatik \\
Block 1: Computability and Complexity }
\author{Exercises 1-10}
\date{SS 2012}


  \newtheorem{theorem}{Theorem}
  \newtheorem{lemma}[theorem]{Lemma}
  \newtheorem{corollary}[theorem]{Corollary}
  \newtheorem{proposition}[theorem]{Proposition}
  \newtheorem{conjecture}[theorem]{Conjecture}
  \newtheorem{definition}[theorem]{Definition}
  \newtheorem{example}[theorem]{Example}
  \newtheorem{remark}[theorem]{Remark}
  \newtheorem{exercise}[theorem]{Exercise}

  \newcommand{\ra}{\rightarrow}
  \newcommand{\Ra}{\Rightarrow}
  \newcommand{\La}{\Leftarrow}
  \newcommand{\la}{\leftarrow}
  \newcommand{\LR}{\Leftrightarrow}

  \renewcommand{\phi}{\varphi}
  \renewcommand{\theta}{\vartheta}


\newcommand{\ccfont}[1]{\protect\mathsf{#1}}
\newcommand{\NP}{\ccfont{NP}}

\newcommand{\NN}{\textbf{N}}
\newcommand{\IN}{\textbf{Z}}
\newcommand{\bigO}{\mathrm{O}}
\newcommand{\bigOmega}{\Omega}
\newcommand{\bigTheta}{\Theta}
\newcommand{\REACHABILITY}{\mbox{\bf REACHABILITY}}
\newcommand{\MAXFLOW}{\mbox{\bf MAX FLOW}}
\newcommand{\MAXFLOWD}{\mbox{\bf MAX FLOW(D)}}
\newcommand{\MAXFLOWSUB}{\mbox{\bf MAX FLOW SUBOPTIMAL}}
\newcommand{\MATCHING}{\mbox{\bf BIPARTITE MATCHING}}
\newcommand{\TSP}{\mbox{\bf TSP}}
\newcommand{\TSPD}{\mbox{\bf TSP(D)}}

\newcommand{\ThreeCol}{\mbox{\bf 3-COLORABILITY}}
\newcommand{\TwoCol}{\mbox{\bf 2-COLORABILITY}}
\newcommand{\kCol}{\mbox{\bf k-COLORABILITY}}
\newcommand{\HamPath}{\mbox{\bf HAMILTON-PATH}}
\newcommand{\HamCycle}{\mbox{\bf HAMILTON-CYCLE}}

\newcommand{\ONESAT}{\mbox{\bf 1-IN-3-SAT}}
\newcommand{\MONONESAT}{\mbox{\bf MONOTONE 1-IN-3-SAT}}
\newcommand{\kSAT}{\mbox{\bf k-SAT}}
\newcommand{\NAESAT}{\mbox{\bf NAESAT}}
\newcommand{\CLIQUE}{\textbf{CLIQUE}\xspace} 
\newcommand{\VC}{\textbf{VERTEX COVER}\xspace}



\renewcommand{\labelenumi}{(\alph{enumi})}

%%% useful macros for Turing machines:
\newcommand{\blank}{\sqcup}
\newcommand{\ssym}{\triangleright}
\newcommand{\esym}{\triangleleft}
\newcommand{\halt}{\mbox{h}}
\newcommand{\yess}{\mbox{``yes''}}
\newcommand{\nos}{\mbox{``no''}}
\newcommand{\lmove}{\leftarrow}
\newcommand{\rmove}{\rightarrow}
\newcommand{\stay}{-}
\newcommand{\diverge}{\nearrow}
\newcommand{\yields}[1]{\stackrel{#1}{\rightarrow}}

\newcommand{\HALTING}{\mbox{\bf HALTING}}

\newcommand{\true}{{\it true}}
\newcommand{\false}{{\it false}}
%\newcommand{\samplesolution}[1]{\noindent {\bf Sample solution.}  #1}
\newcommand{\solution}[1]{\noindent {\bf Solution.}  #1}

\floatname{algorithm}{Procedure}
%\renewcommand{\algorithmicrequire}{\textbf{Input:}}
%\renewcommand{\algorithmicensure}{\textbf{Output:}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}


\maketitle


\begin{exercise}
  Consider the problem \textbf{PROCEDURE NEG-ASSIGNMENT}, which is defined
  as follows:

  \begin{center}
    \fbox{
      \begin{minipage}[c]{.9\linewidth}
        \textbf{PROCEDURE NEG-ASSIGNMENT}

        \medskip INSTANCE: A triple $(\Pi,I, k)$, where (i) $\Pi$ is a
        program that takes one string as input and outputs true or false, (ii) $I$ is a
        string, and (iii) $k$ is an integer variable used in program $\Pi$.     \\
        QUESTION: Does variable $k$ ever get assigned a negative value when the program $\Pi$ is executed with input $I$?

        
      \end{minipage}
    }
  \end{center}
  Prove that \textbf{NEG-ASSIGNMENT} is undecidable. Prove the undecidability
  by providing a reduction from the \textbf{HALTING} problem to
  \textbf{NEG-ASSIGNMENT}, and arguing that your reduction is correct.
\end{exercise}


\solution

To prove the reduction, we have to show that 

\bigskip

$\Pi'$ halts on I $<==>(\Pi, I, k)$ is a positive instance of NEG-ASSIGNMENT.

\bigskip

Let $(\Pi', I') $ be an arbitrary instance of HALTING.  Set $I = I' = S $, let be k an arbitrary integer occuring in $\Pi$ and  construct $(\Pi, I, k) $ in the following way: 

\smallskip


\begin{algorithm}
\caption{NEG-ASSIGNMENT Procedure}
\label{<your label for references later in your document>}
\begin{algorithmic}

\Function{$\Pi$}{String $S$}
 \State int $k = 0$
 %\State I' = I;
 \State call $\Pi^\prime(S)$
 \State k = -1;
 \State return TRUE;
\EndFunction

\end{algorithmic}
\end{algorithm}

\bigskip


$"=>"$

\bigskip

Assume that ($\Pi', I'$ ) is a positive instance of halting, so $\Pi'$ halts on $I$ because we set $I = I'$. Directly after the termination of $\Pi'$, we set $k=-1$, so $(\Pi, I, k)$ is a positive instance of NEG-ASSIGNMENT. 

\bigskip

$"<="$

\bigskip

Assume that $(\Pi, I, k)$ is a positive instance of NEG-ASSIGNMENT, so it returns TRUE which means that k gets negative and the program terminates. But the only time when k gets set to a negative value is directly after the call of $(\Pi', I')$, where $I=I'$, so $\Pi$ halts on $I$, so $(\Pi', I')$ is a positive instance of HALTING. 

\bigskip

\begin{exercise}
  Prove that the problem \textbf{NEG-ASSIGNMENT} from Exercise 1 is semi-decidable. 
To this end, provide a semi-decision procedure and justify your solution. Additionally,  show that the co-problem of \textbf{NEG-ASSIGNMENT} is not semi-decidable.
\end{exercise}

\solution i)

Consider the following interpreter for NEG-ASSIGNMENT. For semi-decidability, the program must return TRUE for all positive instances $(\Pi, I, k)$. The behaviour for negative instances $(\Pi, I, k)$ is such that $\Pi$ return FALSE or loops forever.
So we have to distinguish the following cases:

\begin{itemize}
\item POSITIVE INSTANCE $(\Pi', I')$
\begin{itemize}
\item When $(\Pi', I')$ halts on input $I$, $(\Pi', I')$ is a POSITIVE instance for our halting program, so the variable k gets assigned a negative value and therefore $(\Pi, I, k)$ is a positive assignment of NEG-ASSIGNMENT and returns TRUE
\end{itemize}
\item NEGATIVE INSTANCE $(\Pi', I')$
\begin{itemize}
\item  When $(\Pi', I')$ is a  NEGATIVE instance for our halting program and halts, the variable is NOT touched by our interpreter and remains positive, so $(\Pi, I, k)$ is a NEGATIVE instance on $I$ and returns FALSE
\item When $(\Pi', I')$ is a  NEGATIVE instance for our halting program but does not halt, the variable k cannot be NOT touched by our interpreter and remains positive, so $(\Pi, I, k)$ is a NEGATIVE instance on $I$ and loops forever, which is OK for a semi-decision procedure.
\end{itemize}
\end{itemize}


\begin{algorithm}
\caption{Interpreter for NEG-ASSIGNMENT }
\label{intNEG}
\begin{algorithmic}

\Function{$\Pi$}{String $S$}
 \State int $k = 0$
 \State rc = call $\Pi^\prime(S)$
 \If{$rc = TRUE$}
 \State k = -1;
  \State return TRUE;
 \Else
 \State return FALSE;
 \EndIf
\EndFunction

\end{algorithmic}
\end{algorithm}

\solution ii)

The opposite of NEG-ASSIGNMENT(k gets negative at least one time) is CO-NEG-ASSIGNMENT, which means that k is ALWAYS positive(FIXME!!!!! stimmt das so???)

\begin{exercise}
  Give a formal proof that \textbf{SUBSET SUM} is in $\NP$, i.e.\, define a
  certificate relation and discuss that it is polynomially balanced and
  polynomial-time decidable.
  
   \smallskip
    
  \noindent In the \textbf{SUBSET SUM} problem we are given a finite set of integer numbers $S=\{a_1, a_2, \ldots, a_n\}$ and an integer number $t$. We ask whether there is a subset $S'\subseteq S$ whose elements sum is equal to $t$?
  
\end{exercise}


\solution{ 3}
   \smallskip
First we have to define a certificate relation with an arbitrary t:

\bigskip

$R = \{ [(S,t),S']|  S' \subseteq S $ with $ \sum(S') = t \} $ 

\bigskip
We argue that R is a certificate relation for SUBSET-SUM. $(S,t)$ is a positive instance of SUBSET-SUM $ \Leftrightarrow $ there exist a $S'$ which sum is equal to $t$.   

\bigskip

R is polynomially balanced because any subset of $S$ can be represented in space that is linear in the size in $S$.

\bigskip

Finally R is decidable in polynomial time because, for a given subset of $S$ we can easily check that a the sum is equal to $t$. This needs at most n computational steps. So it can be done in polynomial time.


\begin{exercise}
  \label{ex:partition}
  Formally prove that \textbf{PARTITION} is $\NP$-complete. For this you may use
  the fact that \textbf{SUBSET SUM} is $\NP$-complete.   
  
  \smallskip
  \noindent In the \textbf{PARTITION} problem we are given a finite set of integers $S=\{a_1, a_2, \ldots, a_n\}$. We ask whether the set $S$ can be partitioned into two sets $S_1, S_2$ such that the sum of the numbers in $S1$ equals the sum of the numbers in $S_2$? 
  

\end{exercise}


%\solution{ Your solution here.}


\begin{exercise}
  \label{ex:frequency}
  Formally prove that \textbf{FREQUENCY ASSIGNMENT} is $\NP$-complete. For this you may use
  the fact that a similar problem used in lectures is $\NP$-complete.
      
    \smallskip
        
  \noindent In the \textbf{FREQUENCY ASSIGNMENT} problem we are given a set of transmitters $T=\{t_1, t_2, \ldots, t_n\}$,  $k$ frequencies, and the list of pairs of transmitters that interfer and therefore cannot use the same frequency. We ask whether there is an assignment of each transmitter to one of $k$ frequencies such that there is no interference between the transmitters. 
            
\end{exercise}



%\solution{ Your solution here.}


\begin{exercise}
  \label{ex:CO-NP}
  Fomally prove that logical entailment is $co-\NP$-complete. The formal definition of entailment ( $\models$) is this: $\alpha \models \beta$ if and only if, in every truth assignment in which $\alpha$ is true, $\beta$ is also true.  
\end{exercise}


%\solution{ Your solution here.}



\begin{exercise}
  \label{ex:Colors}
  It is well known that the \textbf{k-COLORABILITY} problem is $\NP$-complete for every $k \geq 3$. Recall that the instance of \textbf{k-COLORABILITY} is an undirected graph $G = (V, E)$. Suppose that we restrict this instance of \textbf{k-COLORABILITY} to trees. Can the restricted problem be solved with an algorithm that runs in polynomial time? If yes, provide such an algorithm. 
\end{exercise}


\solution

By definition, a tree MUST NOT contain any cycles. By modifying DEPTH or BREADTH FIRST SEARCH, we get an algorithm for k-colorability that works in polynominally time. Consider a tree with n - nodes, where every parent-node has x child nodes. One extreme example would be a tree where every node has exactly 1 child. The other extreme would be a tree with 1 parentnode and n-1 childnodes, directly attached to the parent.

Our algorithm has to process every level of the tree, starting at the root-node, coloring the node with one out of k colors. Afterwards, the next level has to be processed. If we take again the extreme with only 2 levels(1 parent, n-1 childs), we have to color (n-1) nodes and the program has finished. Otherwise, if every node has one child, only 1 node has to be colored with another color. This step then must be repeated n times.

Normaly, an average tree will be a mixture of the 2 extremes. This means that we have at most $n$ levels, with $(n-1)$ nodes at each level, which means that the algorithm is $O(n^2)$.  

\begin{mylisting}
\begin{verbatim}

for( every level of the tree )
{
   for( every node in this level )
   {
      color(node, color);
   }
   increment color(color);
}

\end{verbatim}
\end{mylisting}

\begin{algorithmic}
\Function{DFS}{$a$}
\For {each vertex $u \in V[G]$}
% \If {$i\geq maxval$}
    \State $i\gets 0$
% \Else
    color[u] $\gets$ k
    \If {$i+k\leq maxval$}
        \State $i\gets i+k$
    \EndIf
\EndFor
\EndFunction
\end{algorithmic}


\begin{exercise}
  \label{ex:Nqueens}
  Provide a reduction of \textbf{N-Queens} problem to \textbf{SAT}. Give a proof sketch of the correctness of your reduction. Does this implies that the \textbf{N-Queens} is an $\NP$-complete problem? Argue your answer.  
  
  \smallskip 
  
\noindent In the \textbf{N-Queens} problem we are given $n$ queens and an $n \times n$ chessboard. We ask whether we can place these $n$ queens on the  chessboard such that no two queens attack each other. Two queens attack each other if they are placed in the same row, or in the same column, or in the same diagonal.    
       
   
\end{exercise}


%\solution{ Your solution here.}


\begin{exercise}
  Consider the following problem:
  \begin{center}
    \fbox{
      \begin{minipage}[c]{.95\linewidth}
        \textbf{N-SORTED-ELEMENTS}

        \medskip

        INSTANCE: A non-empty list $L=(e_1,\ldots,e_n)$ of non-negative integers. \\
        QUESTION: Does the list $L$ contain a sub-list of $k$ consecutive sorted numbers in ascending order (from left to right)?
      \end{minipage}
    }
  \end{center}

  \medskip Argue that \textbf{N-SORTED-ELEMENTS} can be solved using only logarithmic
  space.
\end{exercise}


\solution{ 9}
To show that problem is solvable in logarithmic space we have to take a look on the elements we need to solve the problem. We only need one pointer to an element in the list and a counter. Both require only logarithmic space. The pseudo algorithm  for
N-SORTED-ELEMENTS works as follows:

\begin{algorithm}
\caption{Boolean N-SORTED-ELEMENTS }
\label{Bsort}
\begin{algorithmic}

\Function{Boolean N-SORTED-ELEMENTS}{List $L$, Integer $k$}
 \State int $i$ ;
 \State int $counter = 0$;
  \For{ i from 2 to length $L$} 
  \If{$L[i] > L[(i-1)]$ then $counter = counter +1$}
   \If{ $ counter  \geq  k$}  return $TRUE$
   \EndIf
   \Else{ $counter = 0$;}
  \EndIf
 \EndFor
 \State return $FALSE$
\EndFunction
\end{algorithmic}
\end{algorithm}

\medskip
The procedure (see procedure 3) uses 2 variables i  and a  counter. For a list $ L = (e1; : : : ; en) $,
the variable i need log n bits to be represented. The
variable counter also only needs logarithmic space. Such a value max needs only
$ log 2^64 x n) = log 2^64 + log n = 64 + log n$ when we assume that the integers are 64-bit integer.
So we can see that the procedure needs only logarithmic space to be represented.



\begin{exercise}
  \label{ex:turing}

  Design a Turing machine that increments by one a value represented by a string of 0s and 1s.
  
\bigskip  
  
\begin{tabular}{|c|c|}
\hline \\
\ hline\\ p $\in $ K &  \\ 
\hline  \\ 
 S  $\triangleright$ & \\ 
\hline  S  $0$ & \\ 
\hline  &  \\ 
\hline  &  \\ 
\hline  &  \\ 
\hline  &  \\ 
\hline  &  \\ 
\hline 
\end{tabular} 
\end{exercise}


%\solution{ Your solution here.}



\end{document}


